今晚才开始刷，早点睡了，就做两题：<br/>
350. Intersection of Two Arrays II（找出两个数组的交集）<br/>
代码如下：<br/>

public class Solution {<br/>

    int max(int n,int m){
        return n>m?n:m;
    }
    
    class Num{
        public int num;
        public boolean visited=false;
        public Num(int n){
            this.num=n;
        }
    }
    
    public int[] intersect(int[] nums1, int[] nums2) {
        int len = max(nums1.length,nums2.length);
        int []result = new int[len];
        int pos=0;
        
        Num[] n1 = new Num[nums1.length];
        Num[] n2 = new Num[nums2.length];
        
        for(int i=0;i<nums1.length;i++){
            n1[i] = new Num(nums1[i]);
        }
        for(int i=0;i<nums2.length;i++){
            n2[i] = new Num(nums2[i]);
        }
        
        for(int i=0;i<nums1.length;i++){
            
            for(int j=0;j<nums2.length;j++){
                if(n1[i].num==n2[j].num&&n2[j].visited==false&&n1[i].visited==false){
                    result[pos++]=n2[j].num;
                    n2[j].visited=true;
                    n1[i].visited=true;
                }
            }
        }
        
        int[] arr = new int[pos];
        for(int i=0;i<pos;i++){
            arr[i]=result[i];
        }
        return arr;
    }
}

330. Patching Array（将所提供的数组中的元素任意组合，找出要覆盖[1,n]区间的话还要向数组中最少添加几个元素）<br/>
我这个思路比较简单，但是比较占内存，最后一个样例覆盖[1,Integer.MAX_VALUE]这个还没过，电脑没电了，先睡了，明天再说吧。。。<br/>
只能说这个思路挺好的，但是对内存过于浪费，记得兴许其它情景这种思路可以有不错的表现哦，不要只局限于本题嘛~<br/>
代码如下：<br/>

public class Solution {<br/>

    public int minPatches(int[] nums, int n) {
        if(n<1)
            return -1;
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i]=0;
        }
        for(int i=0;i<nums.length;i++){
            arr[nums[i]-1]=1;
        }
        List<Integer> list = new ArrayList<Integer>();
        for(int i=1;i<=n;i++){
            if(arr[i-1]==1)
                continue;
            else {
                int pre=i-1;
                boolean flag = false;
                while(pre>0){
                    if(arr[pre-1]==1){
                        if(arr[i-pre-1]==1){
                            flag=true;
                            break;
                        }
                        else {
                            pre--;
                        }
                    }else {
                        pre--;
                    }
                }
                if(flag){
                    //arr[i]=1;
                }else{
                    list.add(i);
                    arr[i-1]=1;
                }
            }
        }
        return list.size();
    }
    }
}

349. Intersection of Two Arrays(呵呵，我刷题的顺序错了。。这题和第一题差不多，改个细节就行了。。。。)

public class Solution {<br/>
    
    int max(int n,int m){
        return n>m?n:m;
    }

    class Num{
        public int num;
        public boolean visited=false;
        public Num(int n){
            this.num=n;
        }
    }
    
    public int[] intersection(int[] nums1, int[] nums2) {
        int len = max(nums1.length,nums2.length);
        Set<Integer> result = new HashSet<Integer>();
        int pos=0;

        Num[] n1 = new Num[nums1.length];
        Num[] n2 = new Num[nums2.length];

        for(int i=0;i<nums1.length;i++){
            n1[i] = new Num(nums1[i]);
        }
        for(int i=0;i<nums2.length;i++){
            n2[i] = new Num(nums2[i]);
        }

        for(int i=0;i<nums1.length;i++){

            for(int j=0;j<nums2.length;j++){
                if(n1[i].num==n2[j].num&&n2[j].visited==false&&n1[i].visited==false){
                    result.add(n2[j].num);
                    n2[j].visited=true;
                    n1[i].visited=true;
                }
            }
        }

        int[] arr = new int[result.size()];
        int i=0;
        Iterator<Integer> iterator = result.iterator();
        while(iterator.hasNext()){
        	arr[i++]=iterator.next();
        }
        return arr;
    }<br/>
    
}

345. Reverse Vowels of a String(字符串逆序，只是加了个条件，只逆序字符串中的元音字母，其实都一样)
写得有点乱啊，之前以为只能用java.lang包下的类而已，什么容器什么的都不敢用，导致之前写的代码很有局限性，施展不开啊。。。
这几次发现可以了，但是我没去写import语句，可能他后台自动引入吧哈哈哈，先不管了反正能用就行~
上代码：

public class Solution {<br/>
    
    public String reverseVowels(String s) {
		List<Integer> positions = new ArrayList<Integer>();
		char[] vowels= new char[s.length()];
		int pos=0;
		StringBuilder builder = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (isVowels(s.charAt(i))) {
				vowels[pos++]=s.charAt(i);
				positions.add(i);
			}
			builder.append(s.charAt(i));
		}
		
		int left=0,right=pos-1;
		while(left<right){
			char tmp = vowels[left];
			vowels[left] = vowels[right];
			vowels[right]=tmp;
			left++;
			right--;
		}
		
		for(int i=0;i<positions.size();i++){
			builder.setCharAt(positions.get(i), vowels[i]);
		}
		return builder.toString();
	}

	private boolean isVowels(char c) {
		if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'
				|| c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')
			return true;
		return false;
	}<br/>
	
}

344. Reverse String(easy的题真是刷的快。。。)

public class Solution {<br/>

    public String reverseString(String s) {
        StringBuilder builder = new StringBuilder(s);
        int left=0,right=s.length()-1;
        while(left<right){
            char tmp = builder.charAt(left);
            builder.setCharAt(left,builder.charAt(right));
            builder.setCharAt(right,tmp);
            left++;
            right--;
        }
        return builder.toString();
    }<br/>
    
}

342. Power of Four(判断是否是4的某次方，别忘了还有0次方。。。)

public class Solution {<br/>

    public boolean isPowerOfFour(int num) {
        if(num==4)return true;
        if(num==1)return true;
        while(num>=4){
            if(num==4)return true;
            if(num%4!=0)return false;
            num/=4;
        }
        return false;
    }<br/>
    
}
