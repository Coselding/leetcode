睡醒刷几题清醒头脑~<br/>
189. Rotate Array（数组整体右移，没难度的。。。）<br/>
<br/>
public class Solution {<br/>

    public void rotate(int[] nums, int k) {
        k%=nums.length;
        int tmp[] = new int[k];
        for(int i=0;i<k;i++){
            tmp[i]=nums[nums.length-1-i];
        }
        for(int i=nums.length-k-1;i>=0;i--){
            nums[i+k]=nums[i];
        }
        for(int i=tmp.length-1,j=0;i>=0;i--){
            nums[j++]=tmp[i];
        }
    }
}

101. Symmetric Tree(二叉树对称判断，二叉树一般想到递归。。。。)<br/>
<br/>

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */<br/>

public class Solution {<br/>

    public boolean isSymmetric(TreeNode root) {
        if(root==null)
            return true;
        else{
            return isSymmetric(root.left,root.right);
        }
    }
    
    boolean isSymmetric(TreeNode left,TreeNode right){
    
        if(left==null&&right==null)return true;//都为空，对称
        if((left!=null&&right==null)||(left==null&&right!=null))return false;//一个不为空，不对称
        //两个都不为空，判断一下~
        //要两个节点的值都想等，并且左子树的左子树和右子树的右子树对称，左子树的右子树和右子树的左子树对称
        if(left.val==right.val&&isSymmetric(left.left,right.right)&&isSymmetric(left.right,right.left))
            return true;
        else return false;
    }
    
}

71. Simplify Path(坑爹的Unix风格的路径特殊情况很多啊，做这道题也好好了解了Unix的路径书写和解析方式。。。)<br/>
对了，字符串匹配开始用的==，未知的错误啊。。。换成equals就没问题了，应该是和字符串常量池等内存分配有关，原谅我还没好好看jvm。。。<br/>
 上代码：<br/>
 
 public class Solution {<br/>

    public String simplifyPath(String path) {<br/>
    
        String ps[] = path.split("/");
		String current[] = new String[256];
		int pos = 0;
		for (int i = 0; i < ps.length; i++) {
			if(ps[i].equals("")){
				
			}
			else if (ps[i].equals(".")) {

			} else if (ps[i].equals("..")) {
				if (pos > 0)
					pos--;
			} else {
				current[pos++] = ps[i];
			}
		}
		String result = "/";
		for (int i = 0; i < pos; i++) {
			if (i < pos - 1)
				result += current[i] + "/";
			else
				result += current[i];
		}
		return result;
    }<br/>
    
}


44. Wildcard Matching(通配符匹配实现，据说要用回溯法或动态规划，先把他过了再来研究。。。)
代码如下：

public class Solution {<br/>
    
    /**
	 * 将多个连续*转换成一个*
	 * 
	 * @param t
	 * @return
	 */
	public String simplifyStar(String t) {
		String r = "";
		for (int i = 0; i < t.length(); i++) {
			r += t.charAt(i);
			if (t.charAt(i) == '*') {
				int pos = i + 1;
				while (pos < t.length() && t.charAt(pos) == '*') {
					i++;
					pos++;
				}
			}
		}
		return r;
	}

	/**
	 * 匹配入口
	 * 
	 * @param s
	 * @param p
	 * @return
	 */
	public boolean isMatch(String s, String p) {
		// p = simplifyStar(p);
		if (!p.contains("*"))
			return equals(s, p);
		else {
			return isMatchStar(s, p);
		}
	}

	/**支持?通配符的equals
	 * @param s1
	 * @param s2
	 * @return
	 */
	public boolean equals(String s1, String s2) {
		int i = 0, j = 0;
		for (; i < s1.length() && j < s2.length(); i++, j++) {
			if (s1.charAt(i) != s2.charAt(j) && s2.charAt(j) != '?')
				return false;
		}
		if (i < s1.length() || j < s2.length())
			return false;
		else
			return true;
	}

	/**支持?通配符的startsWith
	 * @param s
	 * @param p
	 * @return
	 */
	public boolean startsWith(String s, String p) {
		int pos = 0;
		for (int i = 0; i < p.length(); i++) {
			if (pos >= s.length())
				return false;
			if (s.charAt(pos++) != p.charAt(i) && p.charAt(i) != '?')
				return false;
		}
		return true;
	}

	/**
	 * 带*的匹配入口
	 * 
	 * @param s
	 * @param p
	 * @return
	 */
	private boolean isMatchStar(String s, String p) {
		if (p.equals("*"))
			return true;

		String[] str = handleStar(p);

		int pPos = 0;
		if (!str[pPos].equals("")) {
			if (!startsWith(s, str[pPos]))
				return false;
			else {
				s = s.substring(str[pPos].length());
				pPos++;
			}
		}

		String tmp = s;
		while (pPos < str.length - 1) {
			int t = indexOf(tmp, str[pPos]);
			if (t < 0)
				return false;
			tmp = tmp.substring(t + str[pPos].length());
			pPos++;
		}

		if (str[pPos].equals(""))
			return true;
		else {
			return endsWith(tmp, str[pPos]);
		}
	}

	/**支持?通配符的endsWith
	 * @param tmp
	 * @param p
	 * @return
	 */
	private boolean endsWith(String tmp, String p) {
		if (tmp.length() < p.length())
			return false;
		for (int i = p.length() - 1, j = tmp.length() - 1; i >= 0; i--, j--) {
			if (p.charAt(i) != tmp.charAt(j) && p.charAt(i) != '?')
				return false;
		}
		return true;
	}

	/**
	 * 支持?通配符的 indexOf方法
	 * 
	 * @param str
	 * @param sub
	 * @return
	 */
	public int indexOf(String str, String sub) {
		for (int i = 0; i < str.length(); i++) {
			int pos = i;
			boolean flag = true;
			for (int j = 0; j < sub.length(); j++) {
				if (pos>=str.length()||(str.charAt(pos) != sub.charAt(j) && sub.charAt(j) != '?')) {
					flag = false;
					break;
				}
				pos++;
			}
			if (flag)
				return i;
		}
		return -1;
	}

	/**处理多个*连续出现的问题，并把模式字符串按照*分割成各个关键子串，*开头或结尾的话，分别在数组开头或结尾放置一个""标明
	 * @param s
	 * @return
	 */
	public String[] handleStar(String s) {
		String str[] = s.split("\\*");
		List<String> list = new ArrayList<String>();
		for (int i = 0; i < str.length; i++) {
			if (!str[i].equals(""))
				list.add(str[i]);
		}
		int length = list.size();
		boolean f1 = false, f2 = false;
		if (s.startsWith("*")) {
			length++;
			f1 = true;
		}
		if (s.endsWith("*")) {
			length++;
			f2 = true;
		}

		int pos = 0;
		String[] str1 = new String[length];
		if (f1) {
			str1[pos++] = "";
		}
		for (int i = 0; i < list.size(); i++) {
			str1[pos++] = list.get(i);
		}
		if (f2) {
			str1[pos] = "";
		}
		return str1;
	}
}


