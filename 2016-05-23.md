睡醒刷几题清醒头脑~
189. Rotate Array（数组整体右移，没难度的。。。）

public class Solution {
    public void rotate(int[] nums, int k) {
        k%=nums.length;
        int tmp[] = new int[k];
        for(int i=0;i<k;i++){
            tmp[i]=nums[nums.length-1-i];
        }
        for(int i=nums.length-k-1;i>=0;i--){
            nums[i+k]=nums[i];
        }
        for(int i=tmp.length-1,j=0;i>=0;i--){
            nums[j++]=tmp[i];
        }
    }
}

101. Symmetric Tree(二叉树对称判断，二叉树一般想到递归。。。。)

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null)
            return true;
        else{
            return isSymmetric(root.left,root.right);
        }
    }
    
    boolean isSymmetric(TreeNode left,TreeNode right){
        if(left==null&&right==null)return true;//都为空，对称
        if((left!=null&&right==null)||(left==null&&right!=null))return false;//一个不为空，不对称
        //两个都不为空，判断一下~
        //要两个节点的值都想等，并且左子树的左子树和右子树的右子树对称，左子树的右子树和右子树的左子树对称
        if(left.val==right.val&&isSymmetric(left.left,right.right)&&isSymmetric(left.right,right.left))
            return true;
        else return false;
    }
}

71. Simplify Path(坑爹的Unix风格的路径特殊情况很多啊，做这道题也好好了解了Unix的路径书写和解析方式。。。)
对了，字符串匹配开始用的==，未知的错误啊。。。换成equals就没问题了，应该是和字符串常量池等内存分配有关，原谅我还没好好看jvm。。。
 上代码：
 
 public class Solution {
    public String simplifyPath(String path) {
        String ps[] = path.split("/");
		String current[] = new String[256];
		int pos = 0;
		for (int i = 0; i < ps.length; i++) {
			if(ps[i].equals("")){
				
			}
			else if (ps[i].equals(".")) {

			} else if (ps[i].equals("..")) {
				if (pos > 0)
					pos--;
			} else {
				current[pos++] = ps[i];
			}
		}
		String result = "/";
		for (int i = 0; i < pos; i++) {
			if (i < pos - 1)
				result += current[i] + "/";
			else
				result += current[i];
		}
		return result;
    }
}

