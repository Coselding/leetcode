343. Integer Break(给定整数n，将其分解成一些正数的和，求这些正数的乘积，求出乘积最大会是多少。。。)
基本原则：根据周长相等的长方形比正方形面积小来解，至于要分解成两个数还是三个数还是四个数的乘积呢。。。。循环吧。。。
代码如下：

public class Solution {<br/>
    
    public int integerBreak(int n) {
        int max=0;
		for(int i=2;i<=n;i++){
			int tmp = 1;
			int first = n/i;
			int tn = n-first;
			tmp*=first;
			for(int j=1;j<i;j++){
				if(j==i-1){
					tmp*=tn;
				}else {
					tmp*=first;
					tn-=first;
				}
			}
			max=tmp>max?tmp:max;
			
			tmp = 1;
			first = n/i+1;
			tn = n-first;
			tmp*=first;
			for(int j=1;j<i;j++){
				if(j==i-1){
					tmp*=tn;
				}else {
					tmp*=first;
					tn-=first;
					if(tn<first)
						j=i-2;
				}
			}
			max=tmp>max?tmp:max;
		}
		return max;
    }<br/>
    
}

133. Clone Graph(深拷贝图结构，不能用原来的图里的任何引用哦！)
思路：很简单，深度优先搜索或者广度优先搜索，但是由于题目中的图结构中没有标记是否visited的标记变量，只能在搜索中添加一个记录型容器，
遍历过的点放到容器里面，下次再获取这个点的时候直接从容器中取出，不需要在深入遍历，这也是递归的结束条件，原本是没结束条件的，会栈区溢出。。。
代码如下：（这次也算是想到了深度优先和广度优先的新的一种结束控制条件了，学习一下哦~）

/**<br/>
 * Definition for undirected graph.
 * class UndirectedGraphNode {
 *     int label;
 *     List<UndirectedGraphNode> neighbors;
 *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }
 * };
 */<br/>

public class Solution {<br/>
    
    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
		if (node != null) {
			Map<Integer, UndirectedGraphNode> record = new HashMap<Integer, UndirectedGraphNode>();
			return dfs(node, record);
		}
		return null;
	}

	private UndirectedGraphNode dfs(UndirectedGraphNode node,
			Map<Integer, UndirectedGraphNode> record) {
		Integer t = new Integer(node.label);
		if(record.containsKey(t)){
			return record.get(t);
		}
		UndirectedGraphNode node2 = new UndirectedGraphNode(node.label);
		// visited
		record.put(t, node2);
		for (int i = 0; i < node.neighbors.size(); i++) {
			UndirectedGraphNode child = node.neighbors.get(i);
			UndirectedGraphNode n1 = dfs(child,record);
			node2.neighbors.add(n1);
		}
		return node2;
	}
	
}

349. Intersection of Two Arrays(呵呵，我刷题的顺序错了。。这题和第一题差不多，改个细节就行了。。。。)

public class Solution {<br/>
    
    int max(int n,int m){
        return n>m?n:m;
    }

    class Num{
        public int num;
        public boolean visited=false;
        public Num(int n){
            this.num=n;
        }
    }
    
    public int[] intersection(int[] nums1, int[] nums2) {
        int len = max(nums1.length,nums2.length);
        Set<Integer> result = new HashSet<Integer>();
        int pos=0;

        Num[] n1 = new Num[nums1.length];
        Num[] n2 = new Num[nums2.length];

        for(int i=0;i<nums1.length;i++){
            n1[i] = new Num(nums1[i]);
        }
        for(int i=0;i<nums2.length;i++){
            n2[i] = new Num(nums2[i]);
        }

        for(int i=0;i<nums1.length;i++){

            for(int j=0;j<nums2.length;j++){
                if(n1[i].num==n2[j].num&&n2[j].visited==false&&n1[i].visited==false){
                    result.add(n2[j].num);
                    n2[j].visited=true;
                    n1[i].visited=true;
                }
            }
        }

        int[] arr = new int[result.size()];
        int i=0;
        Iterator<Integer> iterator = result.iterator();
        while(iterator.hasNext()){
        	arr[i++]=iterator.next();
        }
        return arr;
    }<br/>
    
}

345. Reverse Vowels of a String(字符串逆序，只是加了个条件，只逆序字符串中的元音字母，其实都一样)
写得有点乱啊，之前以为只能用java.lang包下的类而已，什么容器什么的都不敢用，导致之前写的代码很有局限性，施展不开啊。。。
这几次发现可以了，但是我没去写import语句，可能他后台自动引入吧哈哈哈，先不管了反正能用就行~
上代码：

public class Solution {<br/>
    
    public String reverseVowels(String s) {
		List<Integer> positions = new ArrayList<Integer>();
		char[] vowels= new char[s.length()];
		int pos=0;
		StringBuilder builder = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			if (isVowels(s.charAt(i))) {
				vowels[pos++]=s.charAt(i);
				positions.add(i);
			}
			builder.append(s.charAt(i));
		}
		
		int left=0,right=pos-1;
		while(left<right){
			char tmp = vowels[left];
			vowels[left] = vowels[right];
			vowels[right]=tmp;
			left++;
			right--;
		}
		
		for(int i=0;i<positions.size();i++){
			builder.setCharAt(positions.get(i), vowels[i]);
		}
		return builder.toString();
	}

	private boolean isVowels(char c) {
		if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'
				|| c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')
			return true;
		return false;
	}<br/>
	
}

344. Reverse String(easy的题真是刷的快。。。)

public class Solution {<br/>

    public String reverseString(String s) {
        StringBuilder builder = new StringBuilder(s);
        int left=0,right=s.length()-1;
        while(left<right){
            char tmp = builder.charAt(left);
            builder.setCharAt(left,builder.charAt(right));
            builder.setCharAt(right,tmp);
            left++;
            right--;
        }
        return builder.toString();
    }<br/>
    
}

342. Power of Four(判断是否是4的某次方，别忘了还有0次方。。。)

public class Solution {<br/>

    public boolean isPowerOfFour(int num) {
        if(num==4)return true;
        if(num==1)return true;
        while(num>=4){
            if(num==4)return true;
            if(num%4!=0)return false;
            num/=4;
        }
        return false;
    }<br/>
    
}
