343. Integer Break(给定整数n，将其分解成一些正数的和，求这些正数的乘积，求出乘积最大会是多少。。。)
基本原则：根据周长相等的长方形比正方形面积小来解，至于要分解成两个数还是三个数还是四个数的乘积呢。。。。循环吧。。。
代码如下：

public class Solution {<br/>
    
    public int integerBreak(int n) {
        int max=0;
		for(int i=2;i<=n;i++){
			int tmp = 1;
			int first = n/i;
			int tn = n-first;
			tmp*=first;
			for(int j=1;j<i;j++){
				if(j==i-1){
					tmp*=tn;
				}else {
					tmp*=first;
					tn-=first;
				}
			}
			max=tmp>max?tmp:max;
			
			tmp = 1;
			first = n/i+1;
			tn = n-first;
			tmp*=first;
			for(int j=1;j<i;j++){
				if(j==i-1){
					tmp*=tn;
				}else {
					tmp*=first;
					tn-=first;
					if(tn<first)
						j=i-2;
				}
			}
			max=tmp>max?tmp:max;
		}
		return max;
    }<br/>
    
}

133. Clone Graph(深拷贝图结构，不能用原来的图里的任何引用哦！)
思路：很简单，深度优先搜索或者广度优先搜索，但是由于题目中的图结构中没有标记是否visited的标记变量，只能在搜索中添加一个记录型容器，
遍历过的点放到容器里面，下次再获取这个点的时候直接从容器中取出，不需要在深入遍历，这也是递归的结束条件，原本是没结束条件的，会栈区溢出。。。
代码如下：（这次也算是想到了深度优先和广度优先的新的一种结束控制条件了，学习一下哦~）

/**<br/>
 * Definition for undirected graph.
 * class UndirectedGraphNode {
 *     int label;
 *     List<UndirectedGraphNode> neighbors;
 *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }
 * };
 */<br/>

public class Solution {<br/>
    
    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
		if (node != null) {
			Map<Integer, UndirectedGraphNode> record = new HashMap<Integer, UndirectedGraphNode>();
			return dfs(node, record);
		}
		return null;
	}

	private UndirectedGraphNode dfs(UndirectedGraphNode node,
			Map<Integer, UndirectedGraphNode> record) {
		Integer t = new Integer(node.label);
		if(record.containsKey(t)){
			return record.get(t);
		}
		UndirectedGraphNode node2 = new UndirectedGraphNode(node.label);
		// visited
		record.put(t, node2);
		for (int i = 0; i < node.neighbors.size(); i++) {
			UndirectedGraphNode child = node.neighbors.get(i);
			UndirectedGraphNode n1 = dfs(child,record);
			node2.neighbors.add(n1);
		}
		return node2;
	}
	
}
